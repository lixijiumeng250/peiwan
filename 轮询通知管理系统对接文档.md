# 轮询通知管理系统对接文档

## 概述

本文档介绍陪玩平台后端轮询通知管理系统的实现细节和前端对接方法。系统采用基于数据库的轮询机制来实现实时通知功能，支持员工状态变更通知和工单派发通知。

## 系统架构

### 核心组件

1. **PollNotificationController** - REST API控制器，提供通知相关的HTTP接口
2. **PollNotificationService** - 轮询通知服务接口，定义核心业务方法
3. **PollNotificationServiceImpl** - 轮询通知服务实现类
4. **NotificationService** - 通知业务服务，负责创建和发送通知
5. **NotificationServiceImpl** - 通知业务服务实现类
6. **NotificationMessageMapper** - 数据访问层，操作通知消息表

### 数据存储

通知数据存储在 `notification_messages` 表中，包含以下字段：

```sql
CREATE TABLE notification_messages (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '通知ID',
    type ENUM('EMPLOYEE_STATUS_CHANGE', 'ORDER_ASSIGNMENT', 'ORDER_UPDATE', 'SYSTEM_NOTICE') NOT NULL COMMENT '通知类型',
    recipient_user_id BIGINT NOT NULL COMMENT '接收者用户ID',
    recipient_role ENUM('CS', 'EMPLOYEE', 'ADMIN') NOT NULL COMMENT '接收者用户角色',
    title VARCHAR(200) NOT NULL COMMENT '通知标题',
    content VARCHAR(1000) NOT NULL COMMENT '通知内容',
    data JSON COMMENT '通知数据(JSON格式)',
    is_read BOOLEAN NOT NULL DEFAULT FALSE COMMENT '是否已读',
    priority ENUM('HIGH', 'MEDIUM', 'LOW') NOT NULL DEFAULT 'MEDIUM' COMMENT '优先级',
    expire_time DATETIME COMMENT '过期时间',
    create_time DATETIME NOT NULL COMMENT '创建时间',
    read_time DATETIME COMMENT '读取时间'
);
```

## API 接口文档

### 基础信息

- **Base URL**: `/api/api/notifications`
- **认证**: 需要用户登录认证
- **Content-Type**: `application/json`
- **请求头**: 
  - `Authorization`: Bearer token（必须）
  - `X-User-Id`: 用户ID（必须）
  - `X-Request-Id`: 请求追踪ID（可选）

### 1. 获取未读通知列表

**接口**: `GET /api/api/notifications/unread`

**描述**: 获取当前用户的未读通知列表

**请求参数**:
- `limit` (可选): 限制返回数量，默认50，最大50

**请求示例**:
```http
GET /api/api/notifications/unread?limit=20
Authorization: Bearer <token>
X-User-Id: 12345
```

**响应示例**:
```json
{
  "code": 200,
  "message": "获取未读通知成功",
  "data": [
    {
      "id": 1,
      "type": "EMPLOYEE_STATUS_CHANGE",
      "recipientUserId": 2,
      "recipientRole": "CS",
      "title": "员工状态变更通知",
      "content": "员工 张三 (emp001) 状态变更为空闲，可分配新工单",
      "data": "{\"employeeId\":5,\"employeeName\":\"张三\",\"employeeUsername\":\"emp001\",\"previousStatus\":\"BUSY\",\"currentStatus\":\"IDLE\",\"changeTime\":\"2024-01-01 10:30:00\",\"notificationType\":\"EMPLOYEE_IDLE\",\"message\":\"员工 张三 (emp001) 状态变更为空闲，可分配新工单\",\"responsibleCsIds\":[2,3]}",
      "isRead": false,
      "priority": "MEDIUM",
      "expireTime": "2024-01-01 16:30:00",
      "createTime": "2024-01-01 10:30:00",
      "readTime": null
    }
  ],
  "timestamp": "2024-01-01T10:30:00",
  "requestId": "req-123456"
}
```

### 2. 获取未读通知数量

**接口**: `GET /api/notifications/unread/count`

**描述**: 获取当前用户的未读通知数量

**请求示例**:
```http
GET /api/notifications/unread/count
Authorization: Bearer <token>
```

**响应示例**:
```json
{
  "code": 200,
  "message": "获取未读通知数量成功",
  "data": 5,
  "timestamp": "2024-01-01T10:30:00",
  "requestId": "req-123456"
}
```

### 3. 获取通知列表（分页）

**接口**: `GET /api/notifications`

**描述**: 分页获取当前用户的通知列表

**请求参数**:
- `isRead` (可选): 是否只获取已读/未读通知，不传则获取全部
- `page` (可选): 页码，从1开始，默认1
- `size` (可选): 每页大小，默认20

**请求示例**:
```http
GET /api/notifications?isRead=false&page=1&size=10
Authorization: Bearer <token>
```

**响应示例**:
```json
{
  "code": 200,
  "message": "获取通知列表成功",
  "data": {
    "notifications": [
      {
        "id": 1,
        "type": "ORDER_ASSIGNMENT",
        "recipientUserId": 5,
        "recipientRole": "EMPLOYEE",
        "title": "新工单派发",
        "content": "客服 李四 为您派发了新工单：ORD20240101001",
        "data": "{\"orderId\":10,\"orderNumber\":\"ORD20240101001\",\"clientInfo\":\"用户ABC\",\"orderInfoScreenshotUrl\":\"https://example.com/screenshot.jpg\",\"assignedEmployeeId\":5,\"assignedEmployeeName\":\"张三\",\"csUserId\":2,\"csUserName\":\"李四\",\"assignedTime\":\"2024-01-01 10:30:00\",\"notificationType\":\"ORDER_ASSIGNED\",\"message\":\"客服 李四 为您派发了新工单：ORD20240101001\"}",
        "isRead": false,
        "priority": "HIGH",
        "expireTime": "2024-01-03 10:30:00",
        "createTime": "2024-01-01 10:30:00",
        "readTime": null
      }
    ],
    "page": 1,
    "size": 10,
    "count": 1
  },
  "timestamp": "2024-01-01T10:30:00",
  "requestId": "req-123456"
}
```

### 4. 根据类型获取未读通知

**接口**: `GET /api/notifications/type/{type}`

**描述**: 根据通知类型获取当前用户的未读通知

**路径参数**:
- `type`: 通知类型，可选值：
  - `EMPLOYEE_STATUS_CHANGE` - 员工状态变更
  - `ORDER_ASSIGNMENT` - 工单派发
  - `ORDER_UPDATE` - 工单更新
  - `SYSTEM_NOTICE` - 系统通知

**请求参数**:
- `limit` (可选): 限制返回数量，默认20

**请求示例**:
```http
GET /api/notifications/type/EMPLOYEE_STATUS_CHANGE?limit=10
Authorization: Bearer <token>
```

### 5. 标记通知为已读

**接口**: `POST /api/notifications/{id}/read`

**描述**: 标记指定通知为已读

**路径参数**:
- `id`: 通知ID

**请求示例**:
```http
POST /api/notifications/1/read
Authorization: Bearer <token>
```

**响应示例**:
```json
{
  "code": 200,
  "message": "标记已读成功",
  "data": null,
  "timestamp": "2024-01-01T10:30:00",
  "requestId": "req-123456"
}
```

### 6. 批量标记通知为已读

**接口**: `POST /api/notifications/batch-read`

**描述**: 批量标记指定的通知为已读

**请求体**:
```json
[1, 2, 3, 4, 5]
```

**请求示例**:
```http
POST /api/notifications/batch-read
Authorization: Bearer <token>
Content-Type: application/json

[1, 2, 3, 4, 5]
```

### 7. 标记所有通知为已读

**接口**: `POST /api/notifications/read-all`

**描述**: 标记当前用户的所有未读通知为已读

**请求示例**:
```http
POST /api/notifications/read-all
Authorization: Bearer <token>
```

## 数据结构定义

### NotificationMessage 实体

```java
public class NotificationMessage {
    private Long id;                    // 通知ID
    private NotificationType type;      // 通知类型
    private Long recipientUserId;       // 接收者用户ID
    private RecipientRole recipientRole; // 接收者角色
    private String title;               // 通知标题
    private String content;             // 通知内容
    private String data;                // 通知数据(JSON格式)
    private Boolean isRead;             // 是否已读
    private Priority priority;          // 优先级
    private LocalDateTime expireTime;   // 过期时间
    private LocalDateTime createTime;   // 创建时间
    private LocalDateTime readTime;     // 读取时间
}
```

### 通知类型枚举

```java
public enum NotificationType {
    EMPLOYEE_STATUS_CHANGE("员工状态变更"),
    ORDER_ASSIGNMENT("工单派发"),
    ORDER_UPDATE("工单更新"),
    SYSTEM_NOTICE("系统通知");
}
```

### 接收者角色枚举

```java
public enum RecipientRole {
    CS("客服"),
    EMPLOYEE("员工"),
    ADMIN("管理员");
}
```

### 优先级枚举

```java
public enum Priority {
    HIGH("高"),
    MEDIUM("中"),
    LOW("低");
}
```

### EmployeeStatusNotification DTO

员工状态变更通知的详细数据结构：

```json
{
  "employeeId": 5,
  "employeeName": "张三",
  "employeeUsername": "emp001",
  "previousStatus": "BUSY",
  "currentStatus": "IDLE",
  "changeTime": "2024-01-01 10:30:00",
  "notificationType": "EMPLOYEE_IDLE",
  "message": "员工 张三 (emp001) 状态变更为空闲，可分配新工单",
  "responsibleCsIds": [2, 3]
}
```

### OrderAssignmentNotification DTO

工单派发通知的详细数据结构：

```json
{
  "orderId": 10,
  "orderNumber": "ORD20240101001",
  "clientInfo": "用户ABC",
  "orderInfoScreenshotUrl": "https://example.com/screenshot.jpg",
  "assignedEmployeeId": 5,
  "assignedEmployeeName": "张三",
  "csUserId": 2,
  "csUserName": "李四",
  "assignedTime": "2024-01-01 10:30:00",
  "notificationType": "ORDER_ASSIGNED",
  "message": "客服 李四 为您派发了新工单：ORD20240101001"
}
```

## 前端集成指南

### 1. 轮询策略

建议采用以下轮询策略：

```javascript
class NotificationManager {
  constructor() {
    this.pollingInterval = 5000; // 5秒轮询间隔
    this.isPolling = false;
    this.unreadCount = 0;
  }

  // 启动轮询
  startPolling() {
    if (this.isPolling) return;
    
    this.isPolling = true;
    this.poll();
  }

  // 停止轮询
  stopPolling() {
    this.isPolling = false;
    if (this.pollingTimer) {
      clearTimeout(this.pollingTimer);
    }
  }

  // 执行轮询
  async poll() {
    if (!this.isPolling) return;

    try {
      // 获取未读通知数量
      const countResponse = await fetch('/api/notifications/unread/count', {
        headers: {
          'Authorization': `Bearer ${this.getToken()}`
        }
      });
      
      if (countResponse.ok) {
        const result = await countResponse.json();
        const newCount = result.data;
        
        // 如果有新通知，获取详细信息
        if (newCount > this.unreadCount) {
          await this.fetchNewNotifications();
        }
        
        this.unreadCount = newCount;
        this.updateUI();
      }
    } catch (error) {
      console.error('轮询通知失败:', error);
    }

    // 继续下一次轮询
    this.pollingTimer = setTimeout(() => this.poll(), this.pollingInterval);
  }

  // 获取新通知详情
  async fetchNewNotifications() {
    try {
      const response = await fetch('/api/notifications/unread?limit=10', {
        headers: {
          'Authorization': `Bearer ${this.getToken()}`
        }
      });
      
      if (response.ok) {
        const result = await response.json();
        this.handleNewNotifications(result.data);
      }
    } catch (error) {
      console.error('获取新通知失败:', error);
    }
  }

  // 处理新通知
  handleNewNotifications(notifications) {
    notifications.forEach(notification => {
      // 显示通知弹窗或更新UI
      this.showNotification(notification);
    });
  }

  // 标记通知为已读
  async markAsRead(notificationId) {
    try {
      const response = await fetch(`/api/notifications/${notificationId}/read`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.getToken()}`
        }
      });
      
      if (response.ok) {
        this.unreadCount = Math.max(0, this.unreadCount - 1);
        this.updateUI();
      }
    } catch (error) {
      console.error('标记已读失败:', error);
    }
  }

  // 批量标记为已读
  async markBatchAsRead(notificationIds) {
    try {
      const response = await fetch('/api/notifications/batch-read', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.getToken()}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(notificationIds)
      });
      
      if (response.ok) {
        this.unreadCount = Math.max(0, this.unreadCount - notificationIds.length);
        this.updateUI();
      }
    } catch (error) {
      console.error('批量标记已读失败:', error);
    }
  }

  // 标记所有为已读
  async markAllAsRead() {
    try {
      const response = await fetch('/api/notifications/read-all', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.getToken()}`
        }
      });
      
      if (response.ok) {
        this.unreadCount = 0;
        this.updateUI();
      }
    } catch (error) {
      console.error('标记所有已读失败:', error);
    }
  }
}
```

### 2. Vue.js 集成示例

```vue
<template>
  <div class="notification-panel">
    <!-- 通知图标和数量 -->
    <div class="notification-icon" @click="togglePanel">
      <i class="bell-icon"></i>
      <span v-if="unreadCount > 0" class="badge">{{ unreadCount }}</span>
    </div>

    <!-- 通知面板 -->
    <div v-if="showPanel" class="notification-list">
      <div class="notification-header">
        <h3>通知</h3>
        <button @click="markAllAsRead" v-if="unreadCount > 0">
          全部已读
        </button>
      </div>
      
      <div class="notification-items">
        <div 
          v-for="notification in notifications" 
          :key="notification.id"
          class="notification-item"
          :class="{ 'unread': !notification.isRead }"
          @click="handleNotificationClick(notification)"
        >
          <div class="notification-content">
            <h4>{{ notification.title }}</h4>
            <p>{{ notification.content }}</p>
            <span class="time">{{ formatTime(notification.createTime) }}</span>
          </div>
          <div class="notification-actions">
            <button 
              v-if="!notification.isRead"
              @click.stop="markAsRead(notification.id)"
            >
              标为已读
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'NotificationPanel',
  data() {
    return {
      notifications: [],
      unreadCount: 0,
      showPanel: false,
      pollingTimer: null
    }
  },
  mounted() {
    this.startPolling();
  },
  beforeUnmount() {
    this.stopPolling();
  },
  methods: {
    startPolling() {
      this.poll();
    },
    
    stopPolling() {
      if (this.pollingTimer) {
        clearTimeout(this.pollingTimer);
      }
    },
    
    async poll() {
      try {
        // 获取未读数量
        const countRes = await this.$api.get('/notifications/unread/count');
        this.unreadCount = countRes.data;
        
        // 如果显示面板，获取通知列表
        if (this.showPanel) {
          const listRes = await this.$api.get('/notifications?page=1&size=20');
          this.notifications = listRes.data.notifications;
        }
      } catch (error) {
        console.error('轮询失败:', error);
      }
      
      // 继续轮询
      this.pollingTimer = setTimeout(() => this.poll(), 5000);
    },
    
    async togglePanel() {
      this.showPanel = !this.showPanel;
      if (this.showPanel) {
        await this.loadNotifications();
      }
    },
    
    async loadNotifications() {
      try {
        const response = await this.$api.get('/notifications?page=1&size=20');
        this.notifications = response.data.notifications;
      } catch (error) {
        console.error('加载通知失败:', error);
      }
    },
    
    async markAsRead(notificationId) {
      try {
        await this.$api.post(`/notifications/${notificationId}/read`);
        // 更新本地状态
        const notification = this.notifications.find(n => n.id === notificationId);
        if (notification) {
          notification.isRead = true;
          this.unreadCount = Math.max(0, this.unreadCount - 1);
        }
      } catch (error) {
        console.error('标记已读失败:', error);
      }
    },
    
    async markAllAsRead() {
      try {
        await this.$api.post('/notifications/read-all');
        // 更新本地状态
        this.notifications.forEach(n => n.isRead = true);
        this.unreadCount = 0;
      } catch (error) {
        console.error('全部标记已读失败:', error);
      }
    },
    
    handleNotificationClick(notification) {
      // 根据通知类型处理点击事件
      if (notification.type === 'EMPLOYEE_STATUS_CHANGE') {
        this.handleEmployeeStatusNotification(notification);
      } else if (notification.type === 'ORDER_ASSIGNMENT') {
        this.handleOrderAssignmentNotification(notification);
      }
      
      // 如果未读，标记为已读
      if (!notification.isRead) {
        this.markAsRead(notification.id);
      }
    },
    
    handleEmployeeStatusNotification(notification) {
      try {
        const data = JSON.parse(notification.data);
        // 跳转到员工管理页面
        this.$router.push(`/employee/${data.employeeId}`);
      } catch (error) {
        console.error('解析通知数据失败:', error);
      }
    },
    
    handleOrderAssignmentNotification(notification) {
      try {
        const data = JSON.parse(notification.data);
        // 跳转到工单详情页面
        this.$router.push(`/order/${data.orderId}`);
      } catch (error) {
        console.error('解析通知数据失败:', error);
      }
    },
    
    formatTime(timeString) {
      return new Date(timeString).toLocaleString();
    }
  }
}
</script>
```

### 3. 错误处理

```javascript
class NotificationErrorHandler {
  static handle(error, context) {
    console.error(`通知系统错误 [${context}]:`, error);
    
    // 根据错误类型处理
    if (error.response) {
      const status = error.response.status;
      
      switch (status) {
        case 401:
          // 认证失效，重新登录
          this.handleAuthError();
          break;
        case 403:
          // 权限不足
          this.showMessage('权限不足，无法访问通知');
          break;
        case 500:
          // 服务器错误
          this.showMessage('服务器错误，请稍后重试');
          break;
        default:
          this.showMessage('网络错误，请检查网络连接');
      }
    } else {
      // 网络错误
      this.showMessage('网络连接失败，请检查网络');
    }
  }
  
  static handleAuthError() {
    // 清除token，跳转登录页
    localStorage.removeItem('token');
    window.location.href = '/login';
  }
  
  static showMessage(message) {
    // 显示错误消息（可以使用Element UI的Message组件）
    console.warn(message);
  }
}
```

## 性能优化建议

### 1. 轮询优化

- 根据用户活跃状态调整轮询频率
- 页面不可见时降低轮询频率或暂停轮询
- 使用指数退避策略处理连续失败

### 2. 数据缓存

- 在前端缓存通知列表，减少重复请求
- 使用本地存储保存已读状态
- 实现增量更新机制

### 3. 用户体验

- 提供实时的未读数量显示
- 支持通知分类和过滤
- 实现通知的优先级显示
- 提供声音和视觉提醒

## 注意事项

1. **安全性**：所有API接口都需要用户认证，确保只能访问自己的通知
2. **权限控制**：根据用户角色过滤通知内容
3. **数据清理**：定期清理过期和旧的已读通知
4. **错误处理**：实现完善的错误处理和重试机制
5. **性能监控**：监控轮询频率和服务器负载

## 扩展功能

系统支持以下扩展：

1. **通知推送**：可以集成WebSocket或Server-Sent Events实现实时推送
2. **邮件通知**：重要通知可以同时发送邮件
3. **移动端推送**：集成移动端推送服务
4. **通知模板**：支持自定义通知模板和格式
5. **通知统计**：提供通知的统计和分析功能
